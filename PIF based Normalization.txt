/************************************************************
 * FULL CODE: Rangamati AOI (Rectangle) + PIF-based RGB normalization
 * Landsat-8 (OLI) → Landsat-7 (ETM+) using PIF regression
 * + Before/After cross-sensor consistency stats (Bias + RMSE + Variance)
 *
 * RMSE computed as sqrt(mean(diff^2)) to avoid rootMeanSquare reducer.
 ************************************************************/

/**** 0) AOI: Rangamati rectangle (your AOI) ****/
var aoi = table;
Map.centerObject(aoi, 9);
Map.addLayer(aoi, {}, 'Rangamati AOI');

/**** 1) Cloud mask + SR scaling (Landsat Collection 2 Level-2 SR) ****/
function maskLandsatC2L2(img) {
  var qa = img.select('QA_PIXEL');

  var cloudShadow = qa.bitwiseAnd(1 << 4).neq(0);
  var clouds      = qa.bitwiseAnd(1 << 3).neq(0);
  var snow        = qa.bitwiseAnd(1 << 5).neq(0);

  var mask = cloudShadow.or(clouds).or(snow).not();

  var sr = img.select(['SR_B.*']).multiply(0.0000275).add(-0.2);

  return img.addBands(sr, null, true)
            .updateMask(mask)
            .clip(aoi);
}

function toRGB_L7(img) { return img.select(['SR_B1','SR_B2','SR_B3'], ['B','G','R']); }
function toRGB_L8(img) { return img.select(['SR_B2','SR_B3','SR_B4'], ['B','G','R']); }

/**** 2) Annual composites for overlap years ****/
var startYear  = 2013;
var endYear    = 2020;
var startMonth = 1;
var endMonth   = 12;

function compositeForYear(col, year) {
  year = ee.Number(year);
  var start = ee.Date.fromYMD(year, startMonth, 1);
  var end   = ee.Date.fromYMD(year, endMonth, 28);
  return col.filterDate(start, end).median().set('year', year);
}

/**** 3) Load collections ****/
var L7 = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2')
  .filterBounds(aoi)
  .map(maskLandsatC2L2)
  .map(toRGB_L7);

var L8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  .filterBounds(aoi)
  .map(maskLandsatC2L2)
  .map(toRGB_L8);

print('L7 image count:', L7.size());
print('L8 image count:', L8.size());

var years = ee.List.sequence(startYear, endYear);

/**** 4) Build paired composites (x = L8, y = L7) ****/
var pairs = ee.ImageCollection(years.map(function(y){
  var l7 = compositeForYear(L7, y);
  var l8 = compositeForYear(L8, y);

  return ee.Image.cat(
    l8.select(['B','G','R']).rename(['xB','xG','xR']),
    l7.select(['B','G','R']).rename(['yB','yG','yR'])
  ).set('year', y);
}));

print('pairs size:', pairs.size());

/**** 5) Build robust PIF mask (RGB-only + relaxed stability/brightness) ****/
var gsw = ee.Image('JRC/GSW1_4/GlobalSurfaceWater').select('occurrence');
var nonWater = gsw.lt(50).clip(aoi);

var brightnessCol = pairs.map(function(img){
  var bright = img.select(['xB','xG','xR']).reduce(ee.Reducer.mean()).rename('bright');
  return bright.updateMask(nonWater).set('year', img.get('year'));
});

var brightStd  = brightnessCol.reduce(ee.Reducer.stdDev()).rename('brightStd');
var brightMean = brightnessCol.reduce(ee.Reducer.mean()).rename('brightMean');

var stdP = brightStd.reduceRegion({
  reducer: ee.Reducer.percentile([30]),
  geometry: aoi,
  scale: 30,
  maxPixels: 1e9,
  bestEffort: true,
  tileScale: 4
});
var meanP = brightMean.reduceRegion({
  reducer: ee.Reducer.percentile([10, 90]),
  geometry: aoi,
  scale: 30,
  maxPixels: 1e9,
  bestEffort: true,
  tileScale: 4
});

print('stdP (raw):', stdP);
print('meanP (raw):', meanP);

var stdVals  = ee.Dictionary(stdP).values();
var meanVals = ee.Dictionary(meanP).values();

var stdThr  = ee.Number(stdVals.get(0));
var meanLo  = ee.Number(meanVals.get(0));
var meanHi  = ee.Number(meanVals.get(1));

print('PIF thresholds:', ee.Dictionary({
  brightStd_thr: stdThr,
  brightMean_lo: meanLo,
  brightMean_hi: meanHi
}));

var pifMask = nonWater
  .and(brightStd.lt(stdThr))
  .and(brightMean.gt(meanLo))
  .and(brightMean.lt(meanHi));

Map.addLayer(pifMask.selfMask(), {palette:['yellow']}, 'PIF mask');

/**** 6) Sample PIF pixels and compute bandwise linear fits ****/
var stackedAll = pairs.mosaic();

var sample = stackedAll.updateMask(pifMask).sample({
  region: aoi,
  scale: 30,
  numPixels: 80000,
  seed: 42,
  geometries: false,
  tileScale: 4
});

print('Final PIF sample size:', sample.size());

function fitBand(xName, yName) {
  return sample.reduceColumns({
    reducer: ee.Reducer.linearFit(),
    selectors: [xName, yName]
  });
}

var fitB = fitBand('xB','yB');
var fitG = fitBand('xG','yG');
var fitR = fitBand('xR','yR');

print('Fit (Blue):', fitB);
print('Fit (Green):', fitG);
print('Fit (Red):', fitR);

var aB = ee.Number(fitB.get('offset')), bB = ee.Number(fitB.get('scale'));
var aG = ee.Number(fitG.get('offset')), bG = ee.Number(fitG.get('scale'));
var aR = ee.Number(fitR.get('offset')), bR = ee.Number(fitR.get('scale'));

print('Alpha/Beta (B):', ee.Dictionary({alpha:aB, beta:bB}));
print('Alpha/Beta (G):', ee.Dictionary({alpha:aG, beta:bG}));
print('Alpha/Beta (R):', ee.Dictionary({alpha:aR, beta:bR}));

/**** 7) Apply normalization to an example year and visualize ****/
var testYear = 2019;
var l8Test = compositeForYear(L8, testYear);
var l7Ref  = compositeForYear(L7, testYear);

var l8Norm = ee.Image.cat([
  l8Test.select('B').multiply(bB).add(aB).rename('B'),
  l8Test.select('G').multiply(bG).add(aG).rename('G'),
  l8Test.select('R').multiply(bR).add(aR).rename('R')
]).set('year', testYear);

Map.addLayer(l7Ref,  {min:0, max:0.30}, 'L7 reference RGB');
Map.addLayer(l8Test, {min:0, max:0.30}, 'L8 raw RGB');
Map.addLayer(l8Norm, {min:0, max:0.30}, 'L8 normalized → L7 RGB');

/**** 8) BEFORE/AFTER cross-sensor consistency stats (Bias + RMSE + Variance) ****/
// RMSE computed as sqrt(mean(diff^2))
function diffStats(imgA, imgB, band, mask) {
  var diff = imgA.select(band).subtract(imgB.select(band)).rename('diff');
  var diffMasked = diff.updateMask(mask);

  // bias = mean(diff)
  var bias = diffMasked.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: aoi,
    scale: 30,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 4
  }).get('diff');

  // mse = mean(diff^2) => rmse = sqrt(mse)
  var mse = diffMasked.pow(2).reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: aoi,
    scale: 30,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 4
  }).get('diff');

  // variance of diff
  var variance = diffMasked.reduceRegion({
    reducer: ee.Reducer.variance(),
    geometry: aoi,
    scale: 30,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 4
  }).get('diff');

  return ee.Dictionary({
    bias: bias,
    rmse: ee.Number(mse).sqrt(),
    variance: variance
  });
}

// BEFORE: L8 raw - L7
print('BEFORE Blue:',  diffStats(l8Test, l7Ref, 'B', pifMask));
print('BEFORE Green:', diffStats(l8Test, l7Ref, 'G', pifMask));
print('BEFORE Red:',   diffStats(l8Test, l7Ref, 'R', pifMask));

// AFTER: L8 normalized - L7
print('AFTER Blue:',   diffStats(l8Norm, l7Ref, 'B', pifMask));
print('AFTER Green:',  diffStats(l8Norm, l7Ref, 'G', pifMask));
print('AFTER Red:',    diffStats(l8Norm, l7Ref, 'R', pifMask));





// Q–Q percentiles (1..99)
var ps = ee.List.sequence(1, 99);

// Build FeatureCollection with percentile rows
function qqFC(bandName) {

  // Percentiles on the same PIF mask
  var qL7 = l7Ref.select(bandName).updateMask(pifMask).reduceRegion({
    reducer: ee.Reducer.percentile(ps),
    geometry: aoi,
    scale: 30,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 4
  });

  var qL8raw = l8Test.select(bandName).updateMask(pifMask).reduceRegion({
    reducer: ee.Reducer.percentile(ps),
    geometry: aoi,
    scale: 30,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 4
  });

  var qL8norm = l8Norm.select(bandName).updateMask(pifMask).reduceRegion({
    reducer: ee.Reducer.percentile(ps),
    geometry: aoi,
    scale: 30,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 4
  });

  // Debug once (optional): verify key format
  print('Example keys for ' + bandName + ' (L7):', ee.Dictionary(qL7).keys().slice(0, 10));

  // Table rows: percentile p, and the corresponding values
  var fc = ee.FeatureCollection(ps.map(function(p) {
    p = ee.Number(p).toInt(); // <- critical fix
    var k = ee.String(bandName).cat('_p').cat(p.format('%d')); // <- "R_p1", not "R_p1.0"

    return ee.Feature(null, {
      percentile: p,
      L7: qL7.get(k),
      L8_raw: qL8raw.get(k),
      L8_norm: qL8norm.get(k)
    });
  }));

  return fc;
}

// Q–Q tables for all RGB bands
var qq_blue  = qqFC('B');
var qq_green = qqFC('G');
var qq_red   = qqFC('R');

// Export each
Export.table.toDrive({
  collection: qq_blue,
  description: 'QQ_Blue_L7_vs_L8raw_vs_L8norm_Rangamati_2019',
  fileFormat: 'CSV'
});

Export.table.toDrive({
  collection: qq_green,
  description: 'QQ_Green_L7_vs_L8raw_vs_L8norm_Rangamati_2019',
  fileFormat: 'CSV'
});

Export.table.toDrive({
  collection: qq_red,
  description: 'QQ_Red_L7_vs_L8raw_vs_L8norm_Rangamati_2019',
  fileFormat: 'CSV'
});

